# SPDX-FileCopyrightText: gb-open-market-model contributors
#
# SPDX-License-Identifier: MIT

"""
heat demand shape profile generator.

This script generates the heat demand shape for each sector.
"""

import logging
from pathlib import Path

import numpy as np
import pandas as pd
import xarray as xr

from scripts._helpers import configure_logging, set_scenario_config

logger = logging.getLogger(__name__)


def process_demand_timeseries(
    load_path: str, cop_profile_path: str, heating_mix_path: str, sector: str
) -> pd.DataFrame:
    """
    Generate load profile shape for heat pump demands in each sector

    Args:
        load_path(str): Filepath to the hourly heat load profiles generated by PyPSA-Eur
        cop_profile_path(str): Filepath to hourly weighted COP profiles generated by PyPSA-Eur
        heating_mix_path(str): Filepath to heating technology mix for each heating sector in FES
        sector(str): Sector considered (residential/services)

    Returns:
        pd.DataFrame : electrified heat demand profile for the sector
    """

    cop_profile = pd.read_csv(cop_profile_path, index_col=[0, 1], parse_dates=["time"])
    heating_mix = pd.read_csv(heating_mix_path, index_col=0)

    # Read the electricity demand base .nc file
    load = xr.open_dataset(load_path).to_dataframe().squeeze(axis=1).unstack("node")

    system = ["space", "water"]
    nodes = cop_profile.index.get_level_values(1).unique()
    load_profile = pd.DataFrame(index=load.index, columns=nodes)

    load_profile[sector] = np.zeros(len(load.index))
    for sys in system:
        if sector == "commercial":
            sector_key = "services"
        else:
            sector_key = sector
        load_sys = load[f"{sector_key} {sys}"]

        # Normalized the load profile
        load_normalized = load_sys / load_sys.sum()

        # Compute the electrified heat demand by dividing the heat load by COP
        pump_load = (
            load_normalized.div(cop_profile["ASHP"].unstack("name"))
            * heating_mix.loc["ASHP", sector]
            + load_normalized.div(cop_profile["GSHP"].unstack("name"))
            * heating_mix.loc["GSHP", sector]
            + load_normalized * heating_mix.loc["Electric resistive", sector]
        )

    return pump_load


if __name__ == "__main__":
    if "snakemake" not in globals():
        from scripts._helpers import mock_snakemake

        snakemake = mock_snakemake(Path(__file__).stem, clusters="clustered", year=2022)
    configure_logging(snakemake)
    set_scenario_config(snakemake)

    sectors = ["residential", "commercial"]

    for sector in sectors:
        load_profile = process_demand_timeseries(
            load_path=snakemake.input.load,
            cop_profile_path=snakemake.input.cop_profile,
            heating_mix_path=snakemake.input.heating_mix,
            sector=sector,
        )

        # Save the heat demand load profile
        load_profile.to_csv(snakemake.output[f"{sector}_csv_file"])
        logger.info(
            f"{sector} heat demand profile saved to {snakemake.output[f'{sector}_csv_file']}"
        )
